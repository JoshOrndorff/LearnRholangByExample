#  State Channels

## Holding on to data

![가변은 2015년이다]. 이제는 모두 주(州)의 통로에 관한 겁니다] (변수).png)

지금쯤이면 당신은 투플스페이스로 데이터를 보내는 것과 투플스페이스에서 데이터를 받는 것에 능숙할 것이다. 그러나 당신이 컴퓨터를 할 때마다, 당신은 때때로 나중에 사용하기 위해 데이터를 따로 남겨둘 필요가 있다. 거의 모든 프로그래밍 언어는 변수 개념을 가지고 있다.

Rholang이 독특한 또 다른 방법은 전통적인 변수가 없다는 것이다. 대신, 우리는 데이터를 저장하기 위해 투플스페이스를 사용할 수 있다. 나중에 어떤 것을 예약하고 싶을 때마다, 그것을 어떤 채널로 보내고 나중에 다시 받아. 이러한 방식으로 사용되는 채널은 "주요 채널"이라고 하며, 이름 끝에 "Ch"가 있는 경우가 많다.

[box.rho](box.rho)


어떤 데이터가 '@angerPublicChannel'으로 보내지는가.
- [ ] 0
- [ ] 상자
- [x] 42
- [ ] 비어 있음


BoxCh 상태 채널에 어떤 데이터가 남아 있는가?
- [ ] 0
- [ ] @"일부PublicBox"
- [ ] 42
- [x] 비어 있음


## Persisting Data
만약 우리가 그 상자를 다시 확인한다면, 우리는 결과를 얻지 못할 것이다. 왜냐하면 우리가 일단 메시지를 받으면, 그것은 투플스페이스로부터 소비되기 때문이다. 우리는 끈질긴 송신과 엿보기 수업에서 그 해결책에 대해 간단히 토론했다.

[listentBox.rho](pertentBox.rho)

어떤 데이터가 '@angerPublicChannel'으로 보내지는가.
- [ ] 0
- [ ] 상자
- [x] 42
- [ ] 비어 있음


BoxCh 상태 채널에 어떤 데이터가 남아 있는가?
- [ ] 0
- [ ] @"일부PublicBox"
- [x] 42
- [ ] 비어 있음


## Patience Game Revisited
몇 가지 교훈으로 우리는 각 참가자들이 계약서에 메시지를 보내는 마지막이 되기를 바라는 인내 게임에 대해 토론했다. 우리는 그 당시 몇 가지 문제가 있었다. 왜냐하면 우리는 그 경기의 결과가 산출될 것이라고 보장할 수 없었기 때문이다.

잠시 시간을 내어 우리가 가졌던 문제를 상기시켜라. 우리는 주 채널로 이 문제를 제대로 해결할 수 있다.

[patient.rho] (환자.rho)

위의 코드는 각 블록이 한 번 호출되는 문제를 어떻게 피하는가?
- [ ] 플레이어 1이 상단 블록을 사용하도록 강제 적용
- [x] 처음 통화 후 activeCh가 비어 있기 때문에
- [ ] 상태 채널이 사물을 순차적으로 만들기 때문에

## Objects and Methods
![이 클릭카운터는 증가하고 재설정할 수 있다].(클릭카운터).png)

자바와 같은 "객체 지향 프로그래밍" 언어에서는 데이터를 사용하거나 변경하는 방법과 함께 일부 데이터를 캡슐화하여 실제 개체를 모델링할 수 있다. 같은 것이 Rholang에서도 가능하다.

이 예에서는 기본 클릭 카운터를 나타내는 개체를 만들 것이다. 재료는 다음과 같다.
* 상태 채널: currentCount
* 방법: 증가, 재설정

[카운터.rho]rho)

### Exercises
내가 그것을 확인할 때마다 카운터 값을 수동으로 바꾸는 것은 불편하다. 대신에 우리는 그것에 대한 방법을 가지고 있어야 한다.

<!, checkMethod.rho-->


### Exercises
이제 카운터를 더 쉽고 안전하게 점검할 수 있게 되었으니, 모든 방법을 실제로 점검하는 더 나은 테스트를 써봅시다.

<!, 반시험.rho-->

## Factories
만약 당신이 자바와 같은 다른 언어로 프로그램 했다면 당신은 건설업자들을 잘 알고 있을 것이다. 만약 여러분이 자바에서 프로그램을 짜보지 않았다면, 그것은 훌륭하다. 왜냐하면 Rholang은 공장을 건설자 보다는 새로운 물체를 만들기 위해 사용하기 때문이다.

카운터는 Rholang의 유용한 구조로서, 당신이 당신의 프로젝트에서 그것을 사용한다는 것을 발견할 것이다. 문제는 많은 프로젝트들이 카운터를 사용하고 싶어할 수도 있고, 하나만을 갖는 것은 불충분하다는 것이다. 그래서 해결책은 카운터를 만드는 공장 계약을 만드는 것이다. 공장 계약서가 요청되면, 그것은 완전히 새로운 카운터를 다시 보낸다.

[counterFactory.rho] (counterFactory).rho)

사용자는 새 카운터를 얻기 위해 공장을 어떻게 부를 것인가?
- [ ] "카운터 팩토리!(*ack)'
- [ ] "카운터 팩토리!(0, *ack)"
- [ ] @"counterFactory()".
- [x] counterFactory!(MyIncrease, myReset)".

위에 표시된 대로 만든 후 사용자가 카운터를 재설정하는 방법.
마이 인스!(*ack)'
- [x] 'myReset'!(*ack)'
- [ ] "카운터 팩토리!(MyReset, *ack)"
- [ ] "카운터 팩토리!(마이셋)



## Method Dispatching
방법을 사용할 수 있게 하는 데는 두 가지 기본적인 기술이 있다. 각 방법이 고유의 전용 채널에서 듣기 때문에 내가 "권력의 분리"라고 부르는 첫 번째 옵션.

또 다른 옵션은 제어판이라고 불리는 용서할 수 없는 이름이 하나 있고 모든 방법이 그 위에 만들어지는 "제어판" 기법이다.

```
// 권력 분리
계약 공장(method1, method2) = {
  계약 방법1(ack) = { ... }
  계약 방법2(ack) = { ... }
}

// 제어판
공장(패널) = {
  @[canpanel, "method1"(ack) = { ... }
  @[canpanel, "method2"(ack) = { ... }
}
```

카운터 예시에서는 어떤 기법을 사용하여 방법을 사용했는가?
- [x] 권력 분리
- [ ] 제어판

### Exercises
다른 메서드 디스패치 기술을 사용하려면 카운터 예를 변환하십시오. 너도 시험을 전환해야 한다.
# 데이터 구조

프로그램이 실제 데이터를 처리하고 저장하는 것이 일반적이다. 그리고 당신이 많은 데이터를 가지고 있을 때마다, 당신이 필요한 정보를 빨리 찾을 수 있도록 그것을 정리하는 것이 중요하다. 아날로그 세계에서는 종이파일을 쌓고, 폴더에 넣고, 파일 캐비닛에 넣어 정리한다. 프로그래밍에는 동일한 개념이 적용되며, rholang도 예외는 아니다(한 번!).

데이터 구조를 한 번도 본 적이 없는 경우 다른 참조 자료를 참조하고 추가 예제 코드를 확인하십시오.

## 문자열 방법
친숙한 아이디어부터 시작합시다. 우리는 첫 번째 수업에서 바로 첫 번째 프로그램부터 현악기들을 보아왔다. 사실 문자열은 많은 문자를 정리하는 좋은 방법일 뿐이고, 그것이 그들을 데이터 구조로 만든다. 모든 데이터 구조와 마찬가지로 문자열에는 사용자가 수행할 수 있는 "방법"이 있다.

문자열의 길이 방법은 문자열에 몇 개의 문자가 있는지 알려준다. 슬라이스 방식은 각 엔드에서 몇 개의 문자를 잘라낸 새로운 문자열을 만든다. 스트링스는 '+' 연산자도 지원한다.
[wordLength.rho](wordLength).rho)

헬로 월드(Hello World)의 결과는?
- [ ] 2
- [ ] 10
- [x] 11
- [ ] 정의되지 않음
- [ ] "안녕"

다음 중 "안녕"에게 평가되는 것은?
- [x] "안녕하세요 세계" 슬라이스(1, 5).
- [ ]"헬로 월드".슬라이스(0, 5)"
- [ ]"헬로 월드"슬라이스(1, 4)"
- [ ]"헬로 월드"슬라이스(3, 6)"

문자열에는 유효한 16진수 숫자를 포함하는 문자열에서 작동하도록 설계된 헥스토바이트(hexToBytes) 방법도 있다. 그것은 그 16진수로 표현되는 바이트 배열을 제공한다. "1241243e."hexToBytes()를 실행하십시오.


프로 팁: 바이트 배열을 슬라이싱할 수도 있다. 그것을 직접 실험해 봐.



## Tuples
두 발음이 모두 맞으며, 두 발음이 모두 정확하다. 당신은 전에 계약 c(x, y, z) = { Nil }과 같은 여러 가지 주장을 하는 계약을 작성할 때 튜플을 본 적이 있다. 투플에 있는 품목의 수는 그것의 적자로 알려져 있다. 따라서 계약서 c에 의해 접수된 두 가지는 arity 3이다.

투구에는 몇 개의 데이터가 포함되어 있다. **순서**. 그들은 항상 고정된 경작지이고, 비교적 적은 방법을 가지고 있다. 따라서 그것들은 가장 흥미로운 데이터 구조지만 동시에 가장 근본적인 것이다. 튜플이 제공하는 몇 가지 방법을 살펴보자.

[tuple.rho][tuple.ro]rho)

[3,4,9,Nil]의 장점은?
- [ ] 3
- [x] 4
- [ ] 9
- [ ] Nil

("a", "b", "c"는 무엇인가?nth(3)의 평가 대상은?
- [ ] 3
- [x] 오류
- [ ] "c"
- [ ] ("a", "b", "c")

### Exercise
4쌍을 가지고 요소 0과 3을 화면에 인쇄하는 프로그램을 작성하시오.


## 목록
리스트는 투구와 비슷하지만 괄호 대신 대괄호로 만들어진다. 더 많은 방법이 있고, 끈처럼 '+' 연산자를 이용해 서로 연결하거나 붙일 수 있다. 여기 모든 목록 방법의 예가 있다.

[list.rho](list.rho)

### Exercise
다음 실행 로그 계약 본문을 실행하십시오. 사용자는 자신이 달리던 거리를 통과할 때마다 계약을 요청할 것이다. 그 계약서는 목록에 있는 모든 기록을 남길 것이다. 또한 모든 실행 데이터를 가져오거나 사용자가 실행한 총 거리를 얻기 위한 방법을 작성할 수 있다.

```rholang
새 로그실행, {에서 Chr 실행

  // 시작할 실행 없음
  뛰어!([])|

  계약 로그실행(거리) = {
    // 여기 코드
  }
}
```

## 세트

세트는 어떤 면에서 목록과 비슷하지만, 한가지 큰 차이점은 세트 **이 주문되지 않았다는 것이다. 세트는 프로세스의 모음이지만 세트에 첫 번째 또는 마지막 항목이 없다. 세트에는 **복제**가 허용되지 않는다. 몇 가지 세트 방법을 살펴봅시다.

[set.rho](set.rho)

회비를 지불하지 않은 모든 클럽 회원들의 집합을 만드는 코드는?
- [x] "AllMember.diff(지급된Member)"
- [ ] "payedMembers.diff(allMembers)"
- [ ] "payedMember.union(모든 구성원)"
- [ ] "payedMembers.contains (AllMembers)"

설정(1,2,3) = 셋(3,2,1)의 결과는?
- [x] '참'
- [ ] 'false'
- [ ] 구문이 잘못됨
- [ ] 'Set(2)'

## 지도
지도는 세트와 비슷하지만 **키 값 쌍**을(를) 포함하고 있다. 지도 역시 순서가 맞지 않지만, 항목을 추가할 때(현재 키로 알려짐) 관련 값도 추가하십시오. 여기 지도의 모든 방법의 예가 있다.

[map.rho](map.rho)

{"년"의 결과는 무엇인가? 1, "주": 52, "일": 365}.get(52)
- [ ]주
- [ ]년
- [ ] 52
- [x] Nil

Rholang에서 지도의 유용성을 보여주기 위해, 어느 나라의 수도를 찾는 이 계약을 고려해보자.

[capitalOf.rho](capitalOf.rho)

## 연습
위의 예제 코드에서 시작하는 국가 및 자본 퀴즈 게임을 만들어 사용자가 계약을 호출하고 도전국 및 응답 채널로 돌아오게 하십시오. 그러면 사용자는 그 나라의 수도에 대한 최선의 추측을 응답 채널 위로 다시 보내고 그녀가 맞았는지의 여부를 다시 생각해본다.

멋진 사용자 인터페이스를 사용하여 이 기능을 사용하는 방법에 대한 자세한 내용은 [nthterh]과 같은 몇 가지 dapp 개발 예를 참조하십시오.

## 연습
지도의 '차이' 방식은 또 다른 지도를 논쟁거리로 삼는다. diff map에 동일한 키의 일부가 있지만 서로 다른 값이 연관된 경우 예:
```
{"a": "A", "b": "B", "c": "C"}.diff({"a": 25})
```


## 방법 요약 표

그것은 한번에 데이터 구조에 대한 많은 정보였다. 여기 어떤 방법이 있는지 알려 줄 수 있는 편리한 표가 있다. 이 정보는 또한 [치트시트] (../치트시트)에도 나와 있다.

Method       | Tuple |  List |  Map  |  Set
---          | ----- | ----- | ----- | -----
nth          |   x   |   x   |       |
toByteArray  |   x   |   x   |   x   |   x
union        |       |       |   x   |   x
diff         |       |       |   x   |   x
add          |       |       |       |   x
delete       |       |       |   x   |   x
contains     |       |       |   x   |   x
get          |       |       |   x   |
getOrElse    |       |       |   x   |
set          |       |       |   x   |
keys         |       |       |   x   |
size         |       |       |   x   |   x
length       |       |   x   |       |
slice        |       |   x   |       |



## 복합 이름에서 발송 및 수신
우리는 이 수업에서 몇 가지 흥미로운 데이터 구조에 대해 배웠다. 데이터 구조는 정수, 부울, Nil과 같은 과정이다. 그래서 그들은 인용되고 다른 과정들처럼 이름이 지어질 수 있다. 우리는 다른 이름들처럼 그 이름들로 계약을 맺을 수 있다. 튜플과 같은 데이터 구조에 구축된 이름은 종종 복합 이름이라고 불린다.

이 예에서, 앨리스와 밥은 각각 용서할 수 없는 이름을 가지고 있다. 키는 자체로도 유용할 수 있지만(snippet에 표시되지 않는 사항의 경우), 함께 사용할 때만 표시된 계약을 호출할 수 있다. 이것은 "우리의 증폭"이라고 알려져 있다.
```
new alice, bob, key1, key2, stdout(`rho:io:stdout`) in {

  alice!(*key1)|
  bob!(*key2)|

  contract @(*key1, *key2)(_) = {
    stdout!("Congratulations, Alice and Bob, you've cooperated.")
  }
}
```



`contract @(*self, "getVal")(_) = { Nil }`에서 합성 이름을 만드는 데 사용되는 두 tuple은?
- [ ] `self`
- [ ] `"getval"`
- [x] `(*self, "getVal")`
- [ ] `@(*self, "getVal")`
- [ ] `@"getVal"`
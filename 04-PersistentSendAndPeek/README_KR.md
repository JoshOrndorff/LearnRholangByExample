# 지속성 있는 발송 및 Peek

##왜 반복해서 보내는가?

![이 라디오 내비게이션 보조 장치는 동일한 메시지를 반복해서 방송하여 항공기가 항해를 할 수 있도록 돕는다.(방송.png)

우리의 피자와 커피숍은 같은 재사용 가능한 채널에서 많은 메시지를 받는 것에 관심이 있었다. (msg <= chan){}' 또는 계약 샹(msg){...}`.

항공 교통 관제탑은 같은 메시지를 반복해서 보내는 정반대의 행동을 하는 데 관심이 있을 수 있다. 타워의 관제사들은 날씨와 활성 활주로 정보가 포함된 메시지를 한 번 기록하고, 그것을 필요로 하는 모든 조종사가 이용할 수 있게 하려고 한다. 피자 가게처럼, 그들은 바쁘고 조종사가 그것을 소비할 때마다 계속해서 메시지를 다시 보낼 수 없다.



## 영구 전송 구문

관제탑은 전송을 지속시키기 위해 그들의 코드에서 약간의 조정만 하면 된다. 1인 1조로 보내는 대신 2인 1조로 하는!!`.

[PersistentSend.rho](perstentSend.rho)

원본 전송이 아직 Tuplespace에 있는지 직접 확인하십시오.

### 운동
두 번째 조종사가 정보를 받도록 위의 코드를 수정한다. 여전히 송장은 계속되고 있다.

그런데, 스크린 'stdout'에 아무 것도 인쇄하지 않아도 'new stdout(...)'이 필요하지 않다는 것을 알아챘는가?

for (x <- y) {Nil} | y!!에서 얼마나 많은 통신 이벤트가 발생하는지.(없음)
- [x] '1'
- [ ] '다수'
- [ ] `0`


## 메시지 이중 확인

우리가 방금 보여줬듯이 지속적인 송신과 수신은 매우 유용하다. 그러나 종종 정상적인 송수신 또한 완벽하게 좋다. 항공 교통 관제사들이 날씨가 변할 때 공항 정보를 업데이트하기를 원한다고 상상해 보라. 만약 그들이 지속적인 전송을 사용한다면, 그들은 업데이트를 할 수 없다.

더 나은 해결책은 정상적인 전송을 사용하는 것이며, 메시지를 받은 각 조종사가 메시지를 받은 후에 채널에 다시 보내도록 요구하는 것이다.

[putBack.rho](putBack.rho)

### 운동
이미 알고 있는 것을 이용하면, 정직한 조종사가 정보를 '에어포트Info' 채널에 반환하는 코드를 완성할 수 있다.

그것을 너 혼자서 한번 해 봐. 해결책은 다음과 같다.


for (x <= y) {Nil} | y!!에서 얼마나 많은 통신들이 발생하는지.(없음)
- [ ] `1`
- [x] '다수'
- [ ] `0`



## Peek 구문
위의 코드의 한 가지 문제점은 건망증이 있는 조종사가 실제로 이 정보를 항공모함 채널에 다시 올려놓지 않을 수도 있다는 점이다. 더 나은 해결책은 애초에 그 메시지를 실제로 수신하지 않는 것이다.

![메시지를 한 번 읽어 보면 안 읽고 쓸 수 있다....png)

Rholang은 결국 이런 종류의 것에 대한 특별한 구문을 갖게 될 것이다. 지금 당장은 이용할 수 없지만, 네가 준비될 수 있도록 구문을 보여 줄게. 채널을 사용하지 않고 채널 내용을 "피크"하려면 "<!" 연산자를 사용하십시오.

[pek.rho](pek.rho)


메시지를 엿보기 위해 어떤 구문을 사용하는가?
- [x] 'for (x < y){...}`
- [ ] '(x <= y){...}`
- [ ] x!!y



for (x <! y) {Nil} | y!!에서 얼마나 많은 통신들이 발생하는지.(없음)
- [x] '1'
- [ ] '다수'
- [ ] `0`

## 보안 경고
우리는 건망증이 있는 조종사들이 메시지를 지우고 대신 훔쳐보는 법을 가르쳐줌으로써 메시지를 되돌려 놓는 것을 잊어버리는 문제를 해결했다. 그러나 이것은 여전히 고의적으로 데이터를 수집하는 마니아오 조종사들의 문제를 해결하지 못한다. 현실적으로 우리는 아무도 '에어포트Info'를 비워둘 수 없도록 강제할 필요가 있다. 우리는 6과에서 그것을 어떻게 하는지 볼 것이다.
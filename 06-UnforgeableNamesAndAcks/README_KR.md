# Unforgeable Names and Acks

## Bound and Free Variables

우리는 'for'와 'contract'로 메시지를 받는 법을 배웠다. 이 두 가지 모두 "바인드" 변수를 구성한다. 변수는 실제 값(채널 또는 프로세스)이 연결된 경우 바운드로 간주한다.

이 실세계의 예를 생각해보자. 내 여동생의 이름은 사라야. 내가 "사라"에 대해 가족들과 이야기할 때, 그들은 내 여동생도 알고 있기 때문에 내가 말하는 것을 안다. 그래서 "사라"는 결합된 변수 입니다. 그것은 내 누이동생에게 달려 있다. 하지만 내가 거리에서 아무렇게나 걸어와서 "사라"에 대해 얘기하면, 그들은 이야기의 일반적인 요점을 이해하겠지만, 그들은 그것이 무엇에 관한 것인지 알지 못한다. 왜냐하면 그들에게 "사라"는 어떤 사람에게도 구속되지 않기 때문이다. 이 임의의 낯선 사람에게 "사라"는 "자유로운 변수"이다."

'오더'는 원래 자유변수지만 '커피쇼프' 채널에 들어오는 메시지는 무엇이든간에 붙여진다.

[bound1.rho](bound1.rho)

계약서를 사용할 때도 마찬가지다.

[bound2.rho].rho)


다음의 각 코드 조각에 x가 묶여 있는지 없는지를 명시한다.

(x <- y){닐 }
- [x] 경계
- [ ] 무료
- 둘 다.

(y <- x){Nil}인 경우
- [ ] 경계
- [x] 무료
- 둘 다.

"new x in {x!(참) }"
- [x] 경계
- [ ] 무료
- 둘 다.

'계약 x(y) = { Nil }'
- [ ] 경계
- [x] 무료
- 둘 다.

'계약 y(x) = { Nil }'
- [x] 경계
- [ ] 무료
- 둘 다.

(y <- x){Nil}인 경우
- [ ] 경계
- [x] 무료
- 둘 다.

## 새로운' 연산자
'for'와 'contract'는 연속체 내 결합변수에 이상적이다. 신규 사업자도 변수를 묶는 것으로 드러났다. 무엇 때문에 그들을 묶는가? 메시지를 보내는 데 사용할 수 있는 새 채널을 브랜드로 만드십시오.

[NewPizzaShop.rho](NewPizzaShop.rho)

새로운 제약에서 벗어나 피자를 주문하려고 하면 어떻게 될까.
- [ ] 주문은 잘 된다.
- [ ] 주문은 작동하지만 훨씬 더 오래 걸린다.
- [x] 최상위 자유 변수에 대한 오류
- [ ] 코드가 실행되지만 주문이 수신되지 않음

우리는 모든 이름이 과정을 인용한다는 것을 배웠다. 그렇다면 '피자샵'이라는 이름은 어떤 과정을 인용하는가? 프로세스를 'stdout'으로 인쇄하여 보십시오.
- [ ] '피자밥'을 인용한다.
- [ ] 아무 것도 인용하지 않음
- [x] "일부 허용할 수 없는 16진수 코드"

"new"로 만들어진 Rholang 채널에서는 그들이 인용한 기본 과정에 대한 접근을 제공하지 않는다. 당신이 원한다면 당신은 그들이 "순수한 채널"이라고 생각할 수 있다.

# 개인 vs forgeable

(메시지를 더 이상 도난당할 수는 없지만 도청할 수는 있다.) 경고받았어](도핑.png)

new는 휘어진 가새 또는 "수직 범위" 내에서 생성되는 바인딩된 이름의 사용을 제한하기 때문에 제한 운영자로 알려져 있다. Rholang의 세계 안에서 이 새로운 이름들은 실제로 정확한 범위 내에서만 볼 수 있지만, 인간 프로그래머들은 바깥에서 그 세계를 볼 수 있다는 것을 기억하라. 그것은 특히 블록체인 환경에서 작업할 때 사실이다.

그래서 경쟁하고 있는 피자 가게가 우리 가게를 위한 피자 주문을 소비할 수는 없지만, 그들은 여전히 블록 탐험가를 통해 주문을 읽을 수 있다. 프로그래머들은 가끔 새로운 이름을 "개인"이라고 부르기도 하지만, 더 좋은 용어는 "용서할 수 없다"는 것이 이전 질문에 대한 답을 설명해준다.

## 승인 채널

소통은 항상 한다.png)

용서할 수 없는 이름들의 흔한 용도는 "승인 채널"인데 보통 짧게 "잭" 채널이라고 불린다. 화면에 인쇄하여 모두를 방해함으로써 주문을 확인하는 대신, 피자 가게는 주문이 이루어졌다는 것을 _고객_에게 알려줘야 한다.

그렇게 하려면 피자 가게가 고객에게 연락할 방법을 알아야 한다. 따라서 고객은 다시 호출될 승인 채널을 제공해야 한다. 전통적으로 그러한 채널은 "락"이라고 불린다.

[피자Ack.rho](피자Ack.rho)

이전 예제의 승인이 화면에 나타나지 않는 이유는?
- [ ] 코드에 버그가 있음
- [ ] 주문이 올바르게 수신되지 않음
- [x] 확인이 'stdout'으로 전송되지 않음



# 이름 보내기 권한 부여
우리는 방금 고객이 주문 확인을 받기 위해 콕 채널을 줄 수 있는 방법을 보았다. 우리가 훨씬 더 잘 할 수 있다는 것이 밝혀졌다. 우리의 이전 코드로 밥은 그녀의 콕 채널로 앨리스와 연락할 수 있었다. 그것은 밥이 가짜 콕을 보내서 엘리스가 실제로 주문하지 않았을 때 주문했다고 생각하게 만들 수 있다는 것을 의미한다. 정말로 앨리스와 밥은 그들의 용서할 수 없는 이름들을 엄격하게 통제해야 한다. 왜냐하면 그런 이름을 가진 사람에게 당신에게 연락할 수 있는 능력을 주기 때문이다.

[privateAck.rho](privateAck.rho)

해결책은 새로운 용서할 수 없는 이름을 만들어 피자 가게에 주는 것이다. 그래야 그들이 당신에게 다시 전화할 수 있다. 비록 피자가게가 뉴앨리스의 외부에 있지만, 앨리스는 그 채널의 이름을 주었기 때문에 여전히 그 채널을 보낼 수 있다. 이것은 특권을 위임하는 훌륭한 방법이다.

이 예에서 우리는 콕 채널에서만  shop을 수 있다고 믿지만,  a이 원하면  receive을 수 있다는 것을 알게 된다. 우리는 다음 번 번들에 대한 수업에서 그러한 권한들 중 일부만을 주는 방법을 배울 것이다.

밥은 또한 피자를 주문하고 용서할 수 없는 콕 채널을 만들고 싶어한다. 그는 어디서 그의 용서할 수 없는 채널을 만들어야 하는가?
- [x] 앨리스 코드 다음에 직접 연결
- 앨리스는 같은 줄에
- [ ] 프로그램의 첫 번째 줄에

## 'stdoutAck'와 'stderrAck'

이제 당신은 콕 채널을 이해했으므로, 스크린으로 인쇄하는 두 가지 다른 방법을 알아야 한다. 이 채널들은 'stdoutAck'와 'stderrAck'이다. 그들은 제1과부터의 사촌처럼 일을 하지만 그들은 채널을 고정시킨다.

[stdoutAck.rho](stdoutAck.rho)

그런데, 여러분은 항상 신선한 투플스페이스에서 시작하는 몇 안 되는 것들을 알아차린 적이 있는가? 그 중 4가지는 스크린 인쇄 채널을 위해 내장된 수신이다. 다른 것들은 암호 해독을 위한 것이다. 나중에 얘기하자.


### Exercise
'stdout'("1") | stdout!("2") | stdout!("3")`
이 프로그램은 특정 순서로 번호를 인쇄하지 않는다. 통화는 동시에 일어난다. 우리가 이 선들을 순서대로 인쇄해야 한다고 생각해봐. 콕 채널을 사용하도록 코드를 수정하고 번호가 순서대로 인쇄되는지 확인하십시오.

### Excercise
이 프로그램의 실행 방식(출력 내용 및 투플스페이스에서의 감소 방법)을 예측하십시오. 그리고 나서 그것을 실행해서 너의 예측을 시험해라.
```
{의 새로운 마이찬
  마이찬!("안녕하세요")
}
|
(msg <- mychan) {stdout에 대해!(*msg)}
```

이전 연습에 대한 예측이 잘못된 경우 프로그램이 실제로 예상한 대로 작동하도록 수정하십시오.



## Quiz

for (x <- y){에 바인딩된 이름닐 }
- [x] x
- [ ] 'y'
- [ ] 'Nil'


{Nil}의 새 x에 바인딩된 이름
- [x] x
- [ ] 'y'
- [ ] 'Nil'


만약 pizzzzaShop이 이름이라면 @pizzaShop은 무엇인가?
- [ ] 이름
- [ ] 공정
- [x] 잘못된 구문



왜 피자에크코드가 bob이 아닌 ack채널로 *bob을 보냈을까?
- 이유 없이, 그냥 스타일 선택이야.
- [x] 'bob'은 채널이므로 프로세스를 전송해야 한다.
- [ ] 콕 채널의 특수 구문이다.